<!DOCTYPE html>
<html><head>
<meta charset="UTF-8"/>
<title>Code coverage graphical overview</title>
<script src="d3.v4.min.js" charset="UTF-8"></script>
<script src="d3-tip.js" charset="UTF-8"></script>
<script type="application/javascript">
// Default size of the treemap
var width = 1280, height = 720;

// Coloring functions.
function color_normal(ratio) {
  return isNaN(ratio) ? d3.rgb("white")
                      : d3.rgb((1 - ratio) * 255, ratio * 255, 0);
}
function color_skew(ratio) {
  return color_normal(ratio * ratio);
}
var color_low = d3.interpolateLab("#a50026", "#ffffbf");
var color_high = d3.interpolateLab("#ffffbf", "#006837");
function color_interlab(ratio) {
  return ratio < 0.5 ? color_low(ratio * 2) : color_high(ratio * 2 - 1);
};

var color = color_interlab;

function compute_coverage(prop, d) {
  return color(d.data[prop + '-hit'] / d.data[prop]);
}
var byline = compute_coverage.bind(undefined, 'lines'),
    byfunc = compute_coverage.bind(undefined, 'funcs'),
    bybranch = compute_coverage.bind(undefined, 'branches');

var cur_color = byline;

// Set up the treemap layout engine
var treemap = d3.treemap()
  .size([width, height]);

var size_func = d => d.lines;

// Global display
var display;

var pageopts = {};
var tip;
function onLoad() {
  if (location.search) {
    var pieces = location.search.substring(1).split('&');
    for (var i = 0; i < pieces.length; i++) {
      var aeqb = pieces[i].split('=');
      pageopts[aeqb[0]] = aeqb[1] ? aeqb[1] : "true";
    }
  }
  width = document.getElementById("chart").clientWidth;
  height = width * 9 / 16;
  treemap.size([width, height]);
  display = d3.select("#coverage_treemap")
    .style("position", "relative")
    .style("width", width + "px")
    .style("height", height + "px");
  d3.json("all.json", loadJsonData);

  // Bind the coverage scale
  d3.select("#scale").selectAll("rect")
    .data(new Array(200 - 10).map(function (d, i) { return i; }))
    .enter().append("rect")
    .attr("x", function (d, i) { return i + 5; })
    .attr("y", "0px")
    .attr("width", "1px")
    .attr("height", "15px")
    .attr("fill", function (d, i) { return color(i / 190); });

  d3.select("#scale").append("g")
    .attr("transform", "translate(0, 2)")
    .call(d3.axisBottom(d3.scaleLinear().domain([0,100]).range([5,195]))
                .tickPadding(10).ticks(3));

  // Select changing test suites
  d3.select("#testsuite").on("change", function () {
    d3.json(this.value + ".json", loadJsonData);
    });

  d3.select("#details").on("click", function () {
      location.assign(get_source_file(root));
  });

  tip = d3.tip()
  .attr("class", "tooltip")
  .offset([-10, 0])
  .html(function (d) {
    var str = "File: " + get_source_file(d);
    d = d.data;
    if (d['lines'] > 0)
      str += "<br/>Line coverage: " + d['lines-hit'] + "/" + d.lines +
             " (" + d3.format(".3p")(d['lines-hit'] / d.lines) + ")";
    if (d['funcs'] > 0)
      str += "<br/>Function coverage: " + d['funcs-hit'] + "/" + d.funcs +
             " (" + d3.format(".3p")(d['funcs-hit'] / d.funcs) + ")";
    if (d['branches'] > 0)
      str += "<br/>Branch coverage: " + d['branches-hit'] + "/" + d.branches +
             " (" + d3.format(".3p")(d['branches-hit'] / d.branches) + ")";
    return str;
  }).direction(function (d) {
    var rect = this.getBoundingClientRect();
    if (rect.top < 100 || rect.left < 100)
      return 'e';
    return 'n';
  });

}

var root = null;
var hierarchy;
function loadJsonData(json) {
  root = json;

  // Build a hierarchy for the tree.
  hierarchy = d3.hierarchy(json, d => d.files.length > 0 ? d.files : null);

  // Done loading, display the data tree
  display.text('');
  var hierRoot = hierarchy;
  if (pageopts.dir) {
    var components = pageopts.dir.split('/');
    var newroot = root;
    for (let component of components) {
      var valid = false;
      if (!newroot) break;
      if (hierRoot.children) {
        hierRoot = hierRoot.children.find(d => d.data.name == component);
        if (!hierRoot) {
          display.text(pageopts.dir + " is not a valid path");
          return;
        }
      } else {
        display.text(pageopts.dir + " is not a valid path");
        return;
      }
      for (var j = 0; j < newroot.files.length; j++) {
        if (newroot.files[j].name == component) {
          newroot = newroot.files[j];
          valid = true;
          break;
        }
      }
    }
    if (newroot && valid)
      root = newroot;
  }
  reroot(hierRoot);

  // Change sizes
  d3.select("#size-line").on("click", function() {
    size_func = d => d.lines;
    reroot(root);
    d3.select("#size-line").classed("active", true);
    d3.select("#size-func").classed("active", false);
  });
  d3.select("#size-func").on("click", function() {
    size_func = d => d.funcs;
    reroot(root);
    d3.select("#size-func").classed("active", true);
    d3.select("#size-line").classed("active", false);
  });

  // Change the coloring
  d3.select("#color-line").on("click", function() {
    cur_color = byline;
    display.selectAll("div").style("background-color", cur_color);
    d3.select("#color-line").classed("active", true);
    d3.select("#color-func").classed("active", false);
    d3.select("#color-branch").classed("active", false);
  });
  d3.select("#color-func").on("click", function() {
    cur_color = byfunc;
    display.selectAll("div").style("background-color", cur_color);
    d3.select("#color-func").classed("active", true);
    d3.select("#color-line").classed("active", false);
    d3.select("#color-branch").classed("active", false);
  });
  d3.select("#color-branch").on("click", function() {
    cur_color = bybranch;
    display.selectAll("div").style("background-color", cur_color);
    d3.select("#color-branch").classed("active", true);
    d3.select("#color-line").classed("active", false);
    d3.select("#color-func").classed("active", false);
  });
  // Skew controls disabled due to poor UI to explain it.
  //d3.select("#skew").on("click", function () {
  //  var use_skew = !d3.select("#skew").classed("active");
  //  color = use_skew ? color_skew : color_normal;
  //  display.selectAll("div").style("background-color", cur_color);
  //  d3.select("#skew").classed("active", use_skew);
  //});
}
function bind_layout(d) {
  d.bound_left = d.x + "px";
  d.bound_top = d.y + "px";
  d.bound_width = Math.max(0, d.dx - 1) + "px";
  d.bound_height = Math.max(0, d.dy - 1) + "px";
}
function cell(sel) {
  sel.style("left", function(d) { return d.x0 + "px"; })
     .style("top", function(d) { return d.y0 + "px"; })
     .style("width", function(d) { return Math.max(0, d.x1 - d.x0) + "px"; })
     .style("height", function(d) { return Math.max(0, d.y1 - d.y0) + "px"; })
}

function get_source_file(data) {
  if ("_path" in data)
    return data._path;
  let parents = data.ancestors();
  parents.pop(); // Remove the root node.
  parents.reverse();
  data._path = parents.map(d => d.data.name).join("/");
  return data._path;
}

var display_root = undefined;
function reroot(new_root) {
  document.getElementById("filepath").textContent = get_source_file(new_root);
  root = new_root;
  new_root.sum(d => d.files.length == 0 ? size_func(d) : 0)
    .sort((a, b) => a.value - b.value)
  display_root = treemap(new_root.copy());

  // Move the nodes around
  var nodes = display.data([display_root]).selectAll("div")
    .data(display_root.leaves());
  // Transition the new cells
  nodes.exit().remove();
  nodes.call(cell);
  nodes.enter().append("div").merge(nodes)
    .attr("class", "cell")
    .text(function(d) { return d.data.name; })
    .call(cell)
    .style("background-color", cur_color)
    .on("click", function (d) {
      tip.hide();
      // Ctrl-Click -> up a level
      if (d3.event.ctrlKey) {
        d = root.parent;
      } else {
        // Grab the parent node in the non-cloned hierarchy.
        let ancestors = d.ancestors();
        let ancestor = ancestors[ancestors.length - 2];
        let index = ancestors[ancestors.length - 1].children
          .findIndex(x => x == ancestor);
        d = root.children[index];
      }
      if (d)
        reroot(d);
    })
    // Add details-on-demand tooltips
    .call(tip)
    .on("mouseover", tip.show)
    .on("mouseout", tip.hide);
  nodes.order();
}

</script>
<link href="button.css" rel="stylesheet" type="text/css" />
<style type="text/css">
.cell {
  border: solid 1px black;
  font: 11px sans-serif;
  overflow: hidden;
  position: absolute;
  text-indent: 2px;
  text-overflow: ellipsis;
  /* No need for transition-property, since all things are transitioned */
  /* Disable transitions: the code is broken. */
  /*transition-duration: 1s;
  transition-timing-function: ease-in-out;*/
}

#chart {
  width: 80%;
}

p { margin-top: 0; }
h3 { margin-bottom: 0; }

#sidebar {
  float: right;
  width: 18%;
}
#sidebar > div {
  margin-bottom: 1em;
}

svg { float: right; }
svg text {
  font: 11px sans-serif;
}
path.domain { display: none; }

.tooltip {
  position: absolute;
  font-size: 12px;
  z-index: 10000;
  border-radius: 3px;
  background-color: black;
  color: white;
  padding: 10px 13px;
}
</style>
</head>
<body onload="onLoad()">
<p>Viewing coverage for <span id="filepath"></span></p>
<div id="sidebar">
  <div style="display: inline-block">Scale:
    <svg width="220px" height="2em" style="float: right" id="scale">
    </svg></div>
<div>Color:
<button class='first active' id='color-line'>Line</button><button
        class='' id='color-func'>Function</button><button
        class='last' id='color-branch'>Branch</button>
</div><div>Area:
<button class='first active' id='size-line'>Line</button><button
        class='last' id='size-func'>Function</button>
</div>
<div>Test:
<select id="testsuite">
  ${tests}
</select>
</div>
<button class="first last" id="details">Detailed report</button>
<h3>Instructions:</h3>
<p>In the diagram, every rectangle represents a file in the source tree. The
size that the rectangle occupies is indicative of how many lines or functions
are found in that file, while the color represents what percentage of the file
is covered by various test suites.
<p>Click on a rectangle to go down one level in the directory tree towards that
file. Ctrl-click anywhere in the diagram to go up a level. Hover over any
rectangle to see details about how many lines, functions, and branches are
covered in that file.
</p>
</div>
<div id="chart">
<div id="coverage_treemap">Loading data...</div>
</div>
</body>
</html>
